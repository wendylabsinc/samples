<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Nemotron Speech ASR</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
      .scrollbar-thin::-webkit-scrollbar {
        width: 8px;
      }
      .scrollbar-thin::-webkit-scrollbar-track {
        background: #1f2937;
        border-radius: 4px;
      }
      .scrollbar-thin::-webkit-scrollbar-thumb {
        background: #4b5563;
        border-radius: 4px;
      }
      .scrollbar-thin::-webkit-scrollbar-thumb:hover {
        background: #6b7280;
      }
      .tab-active {
        border-bottom: 2px solid #3b82f6;
        color: #3b82f6;
      }
      .tab-inactive {
        border-bottom: 2px solid transparent;
        color: #9ca3af;
      }
      .tab-inactive:hover {
        color: #d1d5db;
        border-bottom-color: #4b5563;
      }
    </style>
  </head>
  <body class="bg-gray-900 min-h-screen flex flex-col">
    <div class="flex flex-col h-screen">
      <!-- Header -->
      <div class="p-4 bg-gray-800 border-b border-gray-700">
        <h1 class="text-2xl font-bold text-white">Nemotron Speech ASR</h1>
        <p class="text-gray-400 text-sm">
          Real-time speech transcription on the edge
          <span id="status" class="ml-2 inline-flex items-center gap-1.5">
            <span id="status-dot" class="w-2 h-2 rounded-full bg-yellow-500"></span>
            <span id="status-text" class="text-yellow-400">Connecting...</span>
          </span>
        </p>
      </div>

      <!-- Main Content Area -->
      <div class="flex-1 flex flex-col overflow-hidden">
        <!-- Audiogram Area -->
        <div class="relative h-40 bg-gray-950 border-b border-gray-700">
          <canvas id="audiogram-canvas" class="absolute inset-0 w-full h-full"></canvas>
          <div
            id="loading-overlay"
            class="absolute inset-0 flex items-center justify-center bg-gray-950"
          >
            <div class="text-center">
              <svg
                class="animate-spin h-12 w-12 text-blue-500 mx-auto mb-4"
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
              >
                <circle
                  class="opacity-25"
                  cx="12"
                  cy="12"
                  r="10"
                  stroke="currentColor"
                  stroke-width="4"
                ></circle>
                <path
                  class="opacity-75"
                  fill="currentColor"
                  d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                ></path>
              </svg>
              <p id="loading-text" class="text-gray-400">
                Loading Nemotron ASR model...
              </p>
            </div>
          </div>
          <!-- Recording indicator -->
          <div id="recording-indicator" class="absolute top-3 right-3 hidden">
            <span class="flex items-center gap-2 bg-red-500/20 text-red-400 px-3 py-1 rounded-full text-sm">
              <span class="w-2 h-2 bg-red-500 rounded-full animate-pulse"></span>
              Recording
            </span>
          </div>
        </div>

        <!-- Tab Navigation -->
        <div class="flex border-b border-gray-700 bg-gray-800/50 px-4">
          <button
            id="tab-transcriptions"
            class="px-4 py-3 text-sm font-medium transition-colors tab-active"
            onclick="switchTab('transcriptions')"
          >
            Transcriptions
            <span id="transcription-badge" class="ml-2 px-2 py-0.5 text-xs bg-gray-700 rounded-full">0</span>
          </button>
          <button
            id="tab-logs"
            class="px-4 py-3 text-sm font-medium transition-colors tab-inactive"
            onclick="switchTab('logs')"
          >
            Logs
            <span id="log-badge" class="ml-2 px-2 py-0.5 text-xs bg-gray-700 rounded-full">0</span>
          </button>
        </div>

        <!-- Tab Content -->
        <div class="flex-1 flex flex-col overflow-hidden">
          <!-- Transcriptions Tab -->
          <div id="panel-transcriptions" class="flex-1 flex flex-col overflow-hidden p-4">
            <div class="flex-1 overflow-hidden rounded-lg border border-gray-700 bg-gray-800/50">
              <div class="overflow-y-auto h-full scrollbar-thin" id="transcription-container">
                <table class="w-full">
                  <thead class="sticky top-0 bg-gray-800 border-b border-gray-700">
                    <tr>
                      <th class="text-left text-xs font-medium text-gray-400 uppercase tracking-wider px-4 py-3 w-24">Time</th>
                      <th class="text-left text-xs font-medium text-gray-400 uppercase tracking-wider px-4 py-3">Transcription</th>
                      <th class="text-left text-xs font-medium text-gray-400 uppercase tracking-wider px-4 py-3 w-20">Status</th>
                    </tr>
                  </thead>
                  <tbody id="transcription-tbody" class="divide-y divide-gray-700">
                  </tbody>
                </table>
                <!-- Empty state -->
                <div id="empty-state" class="flex flex-col items-center justify-center py-12 text-gray-500">
                  <svg class="w-12 h-12 mb-3 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                  </svg>
                  <p class="text-sm">Waiting for transcriptions...</p>
                  <p class="text-xs text-gray-600 mt-1">Speak into the microphone to begin</p>
                </div>
              </div>
            </div>
          </div>

          <!-- Logs Tab -->
          <div id="panel-logs" class="flex-1 flex flex-col overflow-hidden p-4 hidden">
            <div class="flex items-center justify-between mb-2">
              <span class="text-xs text-gray-500">System and debug messages</span>
              <button onclick="clearLogs()" class="text-xs text-gray-500 hover:text-gray-300 px-2 py-1 rounded hover:bg-gray-700">
                Clear
              </button>
            </div>
            <div class="flex-1 overflow-hidden rounded-lg border border-gray-700 bg-gray-900 font-mono text-sm">
              <div class="overflow-y-auto h-full scrollbar-thin p-3" id="logs-container">
                <div id="logs-content"></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Status Bar -->
      <div id="status-bar" class="bg-gray-800 border-t border-gray-700 px-4 py-2">
        <p id="current-status" class="text-sm text-gray-400 text-center">
          Waiting for audio...
        </p>
      </div>
    </div>

    <script>
      const audiogramCanvas = document.getElementById("audiogram-canvas");
      const ctx = audiogramCanvas.getContext("2d");
      const loadingOverlay = document.getElementById("loading-overlay");
      const loadingText = document.getElementById("loading-text");
      const statusDot = document.getElementById("status-dot");
      const statusText = document.getElementById("status-text");
      const currentStatus = document.getElementById("current-status");
      const transcriptionTbody = document.getElementById("transcription-tbody");
      const transcriptionBadge = document.getElementById("transcription-badge");
      const logBadge = document.getElementById("log-badge");
      const emptyState = document.getElementById("empty-state");
      const recordingIndicator = document.getElementById("recording-indicator");
      const logsContent = document.getElementById("logs-content");

      let ws = null;
      let reconnectTimeout = null;
      let waveformData = [];
      const MAX_WAVEFORM_POINTS = 500;
      let transcriptions = [];
      let logs = [];
      let activeTab = "transcriptions";

      function addLog(level, message) {
        const entry = {
          time: new Date(),
          level: level,
          message: message,
        };
        logs.unshift(entry);

        // Keep logs limited
        if (logs.length > 500) {
          logs.pop();
        }

        logBadge.textContent = logs.length;
        updateLogsDisplay();
      }

      function updateLogsDisplay() {
        const colors = {
          info: "text-blue-400",
          error: "text-red-400",
          warn: "text-yellow-400",
          debug: "text-gray-500",
        };

        logsContent.innerHTML = logs
          .map((log) => {
            const time = log.time.toLocaleTimeString("en-US", {
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
              hour12: false,
            });
            const color = colors[log.level] || "text-gray-400";
            return `<div class="py-1"><span class="text-gray-600">[${time}]</span> <span class="${color}">[${log.level.toUpperCase()}]</span> <span class="text-gray-300">${escapeHtml(log.message)}</span></div>`;
          })
          .join("");
      }

      function clearLogs() {
        logs = [];
        logBadge.textContent = "0";
        logsContent.innerHTML = '<div class="text-gray-600 italic">No logs</div>';
      }

      function switchTab(tab) {
        activeTab = tab;
        const tabTranscriptions = document.getElementById("tab-transcriptions");
        const tabLogs = document.getElementById("tab-logs");
        const panelTranscriptions = document.getElementById("panel-transcriptions");
        const panelLogs = document.getElementById("panel-logs");

        if (tab === "transcriptions") {
          tabTranscriptions.className = "px-4 py-3 text-sm font-medium transition-colors tab-active";
          tabLogs.className = "px-4 py-3 text-sm font-medium transition-colors tab-inactive";
          panelTranscriptions.classList.remove("hidden");
          panelLogs.classList.add("hidden");
        } else {
          tabTranscriptions.className = "px-4 py-3 text-sm font-medium transition-colors tab-inactive";
          tabLogs.className = "px-4 py-3 text-sm font-medium transition-colors tab-active";
          panelTranscriptions.classList.add("hidden");
          panelLogs.classList.remove("hidden");
        }
      }

      function drawAudiogram() {
        const width = audiogramCanvas.width;
        const height = audiogramCanvas.height;
        const centerY = height / 2;

        ctx.fillStyle = "#030712";
        ctx.fillRect(0, 0, width, height);

        ctx.strokeStyle = "#374151";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, centerY);
        ctx.lineTo(width, centerY);
        ctx.stroke();

        if (waveformData.length < 2) return;

        const pointWidth = width / MAX_WAVEFORM_POINTS;
        const startX = width - waveformData.length * pointWidth;

        const gradient = ctx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, "#3b82f6");
        gradient.addColorStop(0.5, "#60a5fa");
        gradient.addColorStop(1, "#3b82f6");

        ctx.strokeStyle = gradient;
        ctx.lineWidth = 2;
        ctx.beginPath();

        waveformData.forEach((value, index) => {
          const x = startX + index * pointWidth;
          const amplitude = value * (height * 0.4);
          const y = centerY - amplitude;

          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });

        ctx.stroke();

        ctx.strokeStyle = "#1d4ed8";
        ctx.lineWidth = 2;
        ctx.beginPath();

        waveformData.forEach((value, index) => {
          const x = startX + index * pointWidth;
          const amplitude = value * (height * 0.35);
          const y = centerY + amplitude;

          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });

        ctx.stroke();
      }

      function resizeCanvas() {
        const container = audiogramCanvas.parentElement;
        audiogramCanvas.width = container.clientWidth;
        audiogramCanvas.height = container.clientHeight;
        drawAudiogram();
      }

      function setStatus(status, color) {
        statusDot.className = `w-2 h-2 rounded-full bg-${color}-500`;
        statusText.textContent = status;
        statusText.className = `text-${color}-400`;
      }

      function setCurrentStatus(text, type) {
        currentStatus.textContent = text;

        switch (type) {
          case "error":
            currentStatus.className = "text-sm text-red-500 text-center";
            break;
          case "transcribing":
            currentStatus.className = "text-sm text-yellow-400 text-center animate-pulse";
            break;
          case "recording":
            currentStatus.className = "text-sm text-blue-400 text-center";
            recordingIndicator.classList.remove("hidden");
            break;
          case "loading":
            currentStatus.className = "text-sm text-gray-400 text-center animate-pulse";
            break;
          default:
            currentStatus.className = "text-sm text-gray-400 text-center";
            recordingIndicator.classList.add("hidden");
        }

        if (type !== "recording") {
          recordingIndicator.classList.add("hidden");
        }
      }

      function formatTime(date) {
        return date.toLocaleTimeString("en-US", {
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          hour12: false,
        });
      }

      function addTranscription(text, hasSpeech) {
        const entry = {
          id: transcriptions.length + 1,
          time: new Date(),
          text: text,
          hasSpeech: hasSpeech,
        };

        transcriptions.unshift(entry);
        updateTranscriptionTable();
        addLog("info", `Transcription: "${text}"`);
      }

      function updateTranscriptionTable() {
        if (transcriptions.length > 0) {
          emptyState.style.display = "none";
        } else {
          emptyState.style.display = "flex";
        }

        transcriptionBadge.textContent = transcriptions.length;

        transcriptionTbody.innerHTML = "";

        transcriptions.forEach((entry) => {
          const row = document.createElement("tr");
          row.className = "hover:bg-gray-700/50 transition-colors";

          const textClass = entry.hasSpeech
            ? "text-white"
            : "text-gray-500 italic";

          const statusBadge = entry.hasSpeech
            ? '<span class="px-2 py-1 text-xs rounded-full bg-green-500/20 text-green-400">Speech</span>'
            : '<span class="px-2 py-1 text-xs rounded-full bg-gray-500/20 text-gray-500">Silent</span>';

          row.innerHTML = `
            <td class="px-4 py-3 text-sm text-gray-400 whitespace-nowrap">${formatTime(entry.time)}</td>
            <td class="px-4 py-3 text-sm ${textClass}">${escapeHtml(entry.text)}</td>
            <td class="px-4 py-3 text-sm">${statusBadge}</td>
          `;

          transcriptionTbody.appendChild(row);
        });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      function connect() {
        if (ws) {
          ws.close();
        }

        addLog("info", "Connecting to WebSocket...");

        const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        ws = new WebSocket(`${protocol}//${window.location.host}/stream`);

        ws.onopen = () => {
          setStatus("Connected", "green");
          addLog("info", "WebSocket connected");
          if (reconnectTimeout) {
            clearTimeout(reconnectTimeout);
            reconnectTimeout = null;
          }
        };

        ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            addLog("debug", `Received: ${data.type}`);

            switch (data.type) {
              case "status":
                if (data.status !== "listening") {
                  addLog("info", `Status: ${data.status} - ${data.message}`);
                }
                if (data.status === "loading") {
                  loadingOverlay.style.display = "flex";
                  loadingText.textContent = data.message;
                  setCurrentStatus(data.message, "loading");
                } else if (data.status === "error") {
                  setCurrentStatus(data.message, "error");
                  addLog("error", data.message);
                } else if (data.status === "transcribing") {
                  setCurrentStatus("Transcribing...", "transcribing");
                } else if (data.status === "recording") {
                  setCurrentStatus("Recording speech...", "recording");
                } else if (data.status === "listening") {
                  setCurrentStatus("Listening for speech...", "default");
                  if (loadingOverlay.style.display !== "none") {
                    loadingOverlay.style.display = "none";
                  }
                }
                break;

              case "waveform":
                if (loadingOverlay.style.display !== "none") {
                  loadingOverlay.style.display = "none";
                }

                if (data.data && data.data.length > 0) {
                  // Downsample raw audio samples for visualization
                  const samples = data.data;
                  const targetPoints = 16; // Points per chunk for smooth display
                  const chunkSize = Math.max(1, Math.floor(samples.length / targetPoints));

                  for (let i = 0; i < samples.length; i += chunkSize) {
                    const chunk = samples.slice(i, i + chunkSize);
                    // Calculate RMS of chunk
                    const rms = Math.sqrt(
                      chunk.reduce((sum, val) => sum + val * val, 0) / chunk.length
                    );
                    waveformData.push(rms);
                  }

                  while (waveformData.length > MAX_WAVEFORM_POINTS) {
                    waveformData.shift();
                  }

                  drawAudiogram();
                }
                break;

              case "spectrogram":
                // Legacy support for spectrogram data
                if (loadingOverlay.style.display !== "none") {
                  loadingOverlay.style.display = "none";
                }

                if (data.data && data.data.length > 0) {
                  data.data.forEach((column) => {
                    const rms = Math.sqrt(
                      column.reduce((sum, val) => sum + val * val, 0) / column.length
                    );
                    waveformData.push(rms);
                  });

                  while (waveformData.length > MAX_WAVEFORM_POINTS) {
                    waveformData.shift();
                  }

                  drawAudiogram();
                }
                break;

              case "transcription":
                addLog("info", `Transcription received: "${data.text}" (has_speech: ${data.has_speech})`);
                addTranscription(data.text, data.has_speech);
                setCurrentStatus(
                  data.has_speech ? "Speech detected" : "No speech detected",
                  "default"
                );
                break;

              case "log":
                addLog(data.level || "info", data.message);
                break;

              case "ping":
                ws.send(JSON.stringify({ type: "pong" }));
                break;
            }
          } catch (e) {
            console.error("Parse error:", e);
            addLog("error", `Parse error: ${e.message}`);
          }
        };

        ws.onerror = (e) => {
          setStatus("Error", "red");
          addLog("error", "WebSocket error");
        };

        ws.onclose = () => {
          setStatus("Disconnected", "red");
          addLog("warn", "WebSocket disconnected");
          loadingOverlay.style.display = "flex";
          loadingText.textContent = "Connection lost...";

          if (!reconnectTimeout) {
            reconnectTimeout = setTimeout(() => {
              setStatus("Reconnecting...", "yellow");
              connect();
            }, 2000);
          }
        };
      }

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();
      addLog("info", "Application started");
      connect();

      window.addEventListener("beforeunload", () => {
        if (ws) {
          ws.close();
        }
      });
    </script>
  </body>
</html>
